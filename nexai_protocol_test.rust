// In progress
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    program_error::ProgramError,
    pubkey::Pubkey,
    msg,
    sysvar::{rent::Rent, Sysvar},
    system_instruction,
    program_pack::{IsInitialized, Sealed},
    program::invoke,
    keccak,
};
use borsh::{BorshSerialize, BorshDeserialize};
use std::str::FromStr;

// Program ID (Devnet)
solana_program::declare_id!("NExAi1111111111111111111111111111111111111");

// ------------------------
// Data Structure
// ------------------------
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct AgentDID {
    pub protocol_version: u8,     // Protocol version (aligned with architecture docs)
    pub creator: Pubkey,          // Creator address
    pub did_seed: [u8; 32],       // DID seed (generated via PDA)
    pub metadata_uri: String,     // Metadata URI (max 256 bytes)
    pub creation_timestamp: i64,  // Timestamp (on-chain validation)
    pub nonce: u32,               // Unique identifier
    pub flags: u8                 // Status flags
}

impl Sealed for AgentDID {}
impl IsInitialized for AgentDID {
    fn is_initialized(&self) -> bool {
        (self.flags & 0x01) != 0
    }
}

// ------------------------
// Enhanced Instruction Set
// ------------------------
#[derive(BorshSerialize, BorshDeserialize)]
pub enum NexAIInstruction {
    CreateAgent {
        uri: String,              // Metadata URI
        seed: [u8; 32]            // Unique seed (generated by frontend)
    },
    UpdateAgentMetadata {
        new_uri: String           // New metadata URI
    }
}

// ------------------------
// Core Logic
// ------------------------
entrypoint!(process_instruction);

fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    let instruction = NexAIInstruction::try_from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;

    match instruction {
        NexAIInstruction::CreateAgent { uri, seed } =>
            create_agent_handler(program_id, accounts, uri, seed),
        NexAIInstruction::UpdateAgentMetadata { new_uri } =>
            update_metadata_handler(accounts, new_uri),
    }
}

// ------------------------
// Create Agent Handler
// ------------------------
fn create_agent_handler(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    uri: String,
    seed: [u8; 32],
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();

    // Account validation sequence
    let authority = validate_account(accounts_iter, true, false)?;  // [0] Contract admin
    let payer = validate_account(accounts_iter, true, true)?;       // [1] Payer account
    let did_account = validate_account(accounts_iter, false, true)?;// [2] DID account
    let system_program = validate_account(accounts_iter, false, false)?; // [3] System program

    // Admin permission check (dynamic config)
    let config = ProgramConfig::load()?;
    if authority.key != &config.admin_pubkey {
        msg!("Permission validation failed");
        return Err(ProgramError::InvalidArgument);
    }

    // Generate PDA
    let (pda, bump) = Pubkey::find_program_address(
        &[b"agent_did", &seed, payer.key.as_ref()],
        program_id
    );
    if pda != *did_account.key {
        msg!("PDA validation failed");
        return Err(ProgramError::InvalidSeeds);
    }

    // Initialize account
    let rent = Rent::get()?;
    invoke(
        &system_instruction::create_account(
            payer.key,
            did_account.key,
            rent.minimum_balance(AgentDID::LEN),
            AgentDID::LEN as u64,
            program_id,
        ),
        &[payer.clone(), did_account.clone(), system_program.clone()],
    )?;

    // Build DID data (with hash validation)
    let did_hash = keccak::hash(uri.as_bytes());
    let mut did_data = AgentDID {
        protocol_version: 2,  // Align with architecture doc version
        creator: *payer.key,
        did_seed: seed,
        metadata_uri: uri,
        creation_timestamp: solana_program::clock::Clock::get()?.unix_timestamp,
        nonce: config.global_nonce,
        flags: 0x01,  // Mark as initialized
    };

    // Data storage
    did_data.serialize(&mut &mut did_account.data.borrow_mut()[..])?;

    // Update global config
    config.increment_nonce()?;

    msg!("Agent DID created | PDA: {} | URI: {}", pda, did_data.metadata_uri);
    Ok(())
}

// ------------------------
// Helper Modules
// ------------------------
struct ProgramConfig {
    admin_pubkey: Pubkey,
    global_nonce: u32,
}

impl ProgramConfig {
    fn load() -> Result<Self, ProgramError> {
        // Should load from persistent storage
        Ok(Self {
            admin_pubkey: Pubkey::from_str("ADMIN_PUBKEY_HERE").unwrap(),
            global_nonce: 0,
        })
    }

    fn increment_nonce(&mut self) -> ProgramResult {
        self.global_nonce = self.global_nonce.wrapping_add(1);
        // Should save to persistent storage
        Ok(())
    }
}

fn validate_account<'a>(
    iter: &mut std::slice::Iter<'a, AccountInfo>,
    is_signer: bool,
    is_writable: bool,
) -> Result<&'a AccountInfo, ProgramError> {
    let account = next_account_info(iter)?;
    if is_signer && !account.is_signer {
        return Err(ProgramError::MissingRequiredSignature);
    }
    if is_writable && !account.is_writable {
        return Err(ProgramError::InvalidAccountData);
    }
    Ok(account)
}
